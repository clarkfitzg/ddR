Wed Aug 10 09:19:05 KST 2016

Indrajit:

> We should avoid the situation where you have features beyond SparkR
> dataframes but people donâ€™t use them due to poor performance. A quick
> solution is to add a suite of performance unit tests that cover small and
> medium sized datasets.

I'm pretty worried about performance and usability of this thing. 
Performance in terms of how long it will take to run, usability in terms of
how feasible it is to use this on anything other than simulated data.
Before I proceed further down this path I'm going to do a few benchmarks
to see if I can get some rough estimates for the bounds on performance.

`do_mapply` is the heart of ddR; everything uses it. Right now my suspicion
based on casual use
is that the version of `mapply` I've implemented on Spark is going to be to
expensive, implying that `do_mapply` will be expensive. Then to get some
reasonable lower bound for performance we can check:

1) How many calls to `do_mapply` happen in various operations.
2) How expensive is a single call to `mapply` on Spark (best and worse
   case).


### How many calls to `do_mapply` happen in various operations?

Following [this
example](http://stackoverflow.com/questions/21687514/r-count-function-calls)
use a global count. This should be fine as long as it runs sequentially.

```

library(ddR)

#count_do_dmapply = 0L
#count_do_collect = 0L

plusone = function(counter_name){
    count = get(counter_name, .GlobalEnv)
    count = count + 1L
    assign(counter_name, count, .GlobalEnv)
}

trace(do_dmapply, tracer = function() plusone("count_do_dmapply")
      , print = FALSE)
trace(do_collect, tracer = function() plusone("count_do_collect")
      , print = FALSE)

counter = function(code_text){
    assign("count_do_dmapply", 0L, .GlobalEnv)
    assign("count_do_collect", 0L, .GlobalEnv)
    eval(parse(text = code_text), envir = .GlobalEnv)
    data.frame(code = code_text
               , do_dmapply = get("count_do_dmapply", .GlobalEnv)
               , do_collect = get("count_do_collect", .GlobalEnv)
               , stringsAsFactors = FALSE
               )
}

count_all = function(codevec){
    do.call(rbind, lapply(codevec, counter))
}


```

### Initializing objects

```

# A million random numbers
a <- matrix(rnorm(1000000), nrow=1000)

init_code = c("dl <- dlist(1:10, letters, runif(10))"
    , "df <- as.dframe(iris)"
    , "dfnum <- as.dframe(iris[, 1:4], psize=c(5, 2))"
    , "da <- as.darray(a, psize = c(100, 100))"
    )

counter(init_code[1])

init_counts = count_all(init_code)

```

### Methods

```

# Dataframes
methods(class = class(df))

ops = count_all(c("df[1:5, 1:2]"
    , "df$Species"
    , "colMeans(dfnum)"
    , "rowSums(dfnum)"
    , "mean(dfnum)"
    , "da[1:300, 357:498]"
    , "colMeans(da)"
    , "rowSums(da)"
    , "mean(da)"
    #, "rbind(da, da)" # Fails, but for a different reason?
))

ops

```

Ah, dlists, darrays, and dframes are all the same class. But how does OO programming work then?

### Functions

```

ddR_funs = count_all(c("da[1:300, 357:498]"
    , "colMeans(da)"
))



```
